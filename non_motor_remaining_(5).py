# -*- coding: utf-8 -*-
"""non motor remaining (5).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IdKjw9VUAv2quzM0IYEcNaNuordzKNhe
"""

import pandas as pd

# Load your two CSV files - please replace with actual file paths
df2 = pd.read_csv(r"E:\pd-data\non motor\mood\QUIP-Current-Short_11Sep2025.csv")

df2['PATNO'] = df2['PATNO'].astype(str)
df2['EVENT_ID'] = df2['EVENT_ID'].astype(str)

# List of columns to keep (plus identifiers)
cols_to_keep = [
     'TMGAMBLE','CNTRLGMB',
    'TMSEX','CNTRLSEX','TMBUY','CNTRLBUY','TMEAT','CNTRLEAT','TMTORACT','TMTMTACT','TMTRWD',
    'TMDISMED','CNTRLDSM'
]

# Add common identifier columns (replace these with your actual column names)
id_cols = ['PATNO', 'EVENT_ID']

# Select columns safely if they exist in the data
df2_Selected = df2[id_cols + [col for col in cols_to_keep if col in df2.columns]]

df2_Selected.head(10)

print(type(df2_Selected['PATNO'].iloc[0]))  # Should be <class 'str'>

import pandas as pd

# Load the participant status file
df_cohort_full = pd.read_csv(r"E:\pd-data\enrollment\Participant_Status_16Sep2025.csv")

# Print columns to identify the correct cohort column name
print(df_cohort_full.columns)

# Replace 'COHORT' with the actual cohort column from above!
df_cohort = df_cohort_full[['PATNO', 'COHORT']].copy()

print(df_cohort.head())

print(df2_Selected.shape)
print(df2_Selected.head())

print("Sample PATNOs in df2_Selected:", df2_Selected['PATNO'].unique()[:10])
print("Sample PATNOs in pd_patnos:", list(pd_patnos)[:10])

print(type(list(pd_patnos)[0]))  # Should be <class 'str'>
print(type(df2_Selected['PATNO'].iloc[0]))  # Should be <class 'str'>

# Ensure PATNO is string in both DataFrames
df_cohort['PATNO'] = df_cohort['PATNO'].astype(str)
df_cohort['COHORT'] = df_cohort['COHORT'].astype(str)
df2_Selected['PATNO'] = df2_Selected['PATNO'].astype(str)

df_cohort['COHORT'] = df_cohort['COHORT'].str.strip()
df_cohort['PATNO'] = df_cohort['PATNO'].str.strip()
pd_patnos = set(df_cohort[df_cohort['COHORT'] == '1']['PATNO'])
df2_Selected = df2_Selected[df2_Selected['PATNO'].isin(pd_patnos)]
print(pd_patnos)

df2_Selected.head()
print(df2_Selected.shape)

df_cohort.head()

# Ensure PATNO and EVENT_ID are strings
df2_Selected['PATNO'] = df2_Selected['PATNO'].astype(str)
df2_Selected['EVENT_ID'] = df2_Selected['EVENT_ID'].astype(str)

# Get the visit sequences per patient in df2_Selected
visit_sequences = df2_Selected.groupby('PATNO')['EVENT_ID'].apply(list)

positions = {}
for visits in visit_sequences:
    for pos, eid in enumerate(visits, 1):
        if eid not in positions:
            positions[eid] = []
        positions[eid].append(pos)

# Average position per EVENT_ID
mean_positions = {eid: sum(pos_list) / len(pos_list) for eid, pos_list in positions.items()}

# Sort EVENT_IDs by mean position
sorted_eids = sorted(mean_positions, key=mean_positions.get)
n = len(sorted_eids)

# Assign early, mid, late categories
visit_categories = {}
for i, eid in enumerate(sorted_eids):
    if i < n // 3:
        visit_categories[eid] = 'early'
    elif i < 2 * n // 3:
        visit_categories[eid] = 'mid'
    else:
        visit_categories[eid] = 'late'

# Map these categories to a new column in df2_Selected
df2_Selected['visit_phase'] = df2_Selected['EVENT_ID'].map(visit_categories)

print(df2_Selected[['EVENT_ID', 'visit_phase']].drop_duplicates())

import matplotlib.pyplot as plt

mood_symptom_cols = [
    'TMGAMBLE','CNTRLGMB','TMSEX','CNTRLSEX','TMBUY','CNTRLBUY',
    'TMEAT','CNTRLEAT','TMTORACT','TMTMTACT','TMTRWD','TMDISMED','CNTRLDSM'
]

visit_phase_mapping = {
    'BL': 'early', 'R17': 'early', 'R18': 'mid', 'SC': 'early', 'TRANS': 'mid',
    'V01': 'mid', 'V02': 'mid', 'V03': 'mid', 'V04': 'mid', 'V05': 'mid',
    'V06': 'mid', 'V07': 'late', 'V08': 'late', 'V09': 'late', 'V10': 'late',
    'V11': 'late', 'V12': 'late', 'V14': 'late', 'V15': 'late', 'V17': 'late',
    'V18': 'late', 'R19': 'mid', 'R20': 'mid', 'V19': 'late', 'V20': 'late',
    'ST': 'mid', 'V13': 'late', 'V21': 'late', 'R16': 'early', 'V16': 'late',
    'R15': 'early', 'PW': 'early', 'RS1': 'mid', 'R21': 'mid', 'U02': 'mid',
    'U01': 'mid', 'V22': 'late', 'R14': 'mid', 'R13': 'early', 'LOG': 'early',
    'R08': 'early', 'R10': 'early', 'R12': 'early', 'R06': 'early', 'R04': 'early',
    'R01': 'early'
}


# Convert symptom values to binary presence (1 if symptom value == 1, else 0)
mean_presence = df2_Selected.groupby('EVENT_ID')[mood_symptom_cols].apply(
    lambda df: df.applymap(lambda x: 1 if x == 1 else 0).mean()
)

# Filter visit order for plotting
filtered_visit_order = [v for v in visit_phase_mapping.keys() if v in mean_presence.index]
mean_presence = mean_presence.loc[filtered_visit_order]

# Map phase (early > mid > late) based on max mean presence
symptom_phase_map = {}
for col in mood_symptom_cols:
    max_val = mean_presence[col].max()
    max_visits = mean_presence.index[mean_presence[col] == max_val]
    phases = {visit_phase_mapping.get(v, 'unknown') for v in max_visits}
    if 'early' in phases:
        phase = 'early'
    elif 'mid' in phases:
        phase = 'mid'
    elif 'late' in phases:
        phase = 'late'
    else:
        phase = 'unknown'
    symptom_phase_map[col] = phase

plt.figure(figsize=(13, 7))
for col in mood_symptom_cols:
    label = f"{col}: {symptom_phase_map[col].capitalize()}"
    plt.plot(mean_presence.index, mean_presence[col], marker='o', linewidth=2, label=label)

plt.ylabel('Symptom Presence (mean proportion)', fontsize=14)
plt.xlabel('Visit (EVENT_ID)', fontsize=14)
plt.title('Mood Symptom Onset Progression by Visit', fontsize=16)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.legend(loc='upper left', bbox_to_anchor=(1.0, 1.0), fontsize=10, ncol=2)
plt.tight_layout()
plt.show()

# SCAU1-SCAU26DT: SCOPA-AUT symptom item (0=never, 1=sometimes, 2=regularly, 3=often, sometimes 9=use catheter, or 9=not applicable depending on item)
# PTINBOTH: mood form responder (1=Patient, 2=Informant, 3=Both)
# TMGAMBLE: gambling impulse symptom (0=No, 1=Yes)
# CNTRLGMB: control question for gambling (0=No, 1=Yes)
# TMSEX: hypersexuality impulse symptom (0=No, 1=Yes)
# CNTRLSEX: control for sexual impulse (0=No, 1=Yes)
# TMBUY: compulsive buying symptom (0=No, 1=Yes)
# CNTRLBUY: control for buying impulse (0=No, 1=Yes)
# TMEAT: binge eating impulse symptom (0=No, 1=Yes)
# CNTRLEAT: control for eating impulse (0=No, 1=Yes)
# TMTORACT: compulsive hobby/ritual symptom (0=No, 1=Yes)
# TMTMTACT: compulsive time management act symptom (0=No, 1=Yes)
# TMTRWD: reward-driven behavior symptom (0=No, 1=Yes)
# TMDISME: disordered medication use symptom (0=No, 1=Yes, 2=Not Applicable)
# CNTRLDSM: control for medication impulse (0=No, 1=Yes, 2=Not Applicable)

import os
df2_Selected['EVENT_ID'] = df2_Selected['EVENT_ID'].astype(str)
df2_Selected.to_parquet('df2_Selected.parquet', engine='pyarrow', index=False)

df2_Selected.columns

file_paths = [
    r'E:\pd-data\non motor\neuro\Clock_Drawing_11Sep2025.csv',
    r'E:\pd-data\non motor\neuro\Montreal_Cognitive_Assessment__MoCA__11Sep2025.csv']

selected_cols_file1 = [
    'PATNO', 'EVENT_ID','CLCKPII','CLCK2HND','CLCKNMRK',
    'CLCKNUIN','CLCKALNU','CLCKNUSP','CLCKNUED','CLCKTOT'
]
selected_cols_file2 = ['PATNO','EVENT_ID','MCAALTTM','MCACUBE','MCACLCKC','MCACLCKN','MCACLCKH','MCALION','MCARHINO','MCACAMEL','MCAFDS','MCABDS','MCAVIGIL','MCASER7','MCASNTNC','MCAVFNUM','MCAVF','MCAABSTR','MCAREC1','MCAREC2','MCAREC3','MCAREC4','MCAREC5','MCADATE','MCAMONTH','MCAYR','MCADAY','MCAPLACE','MCACITY']

cogcat_df = pd.read_csv(file_paths[0])[selected_cols_file1]
neuro_df = pd.read_csv(file_paths[1])[selected_cols_file2]

merged_df = cogcat_df.merge(neuro_df, on=['PATNO', 'EVENT_ID'], how='inner')

print(merged_df.head())

# Ensure PATNO is string in both DataFrames
df_cohort['PATNO'] = df_cohort['PATNO'].astype(str)
df_cohort['COHORT'] = df_cohort['COHORT'].astype(str)
merged_df['PATNO'] = merged_df['PATNO'].astype(str)

df_cohort['COHORT'] = df_cohort['COHORT'].str.strip()
df_cohort['PATNO'] = df_cohort['PATNO'].str.strip()
pd_patnos = set(df_cohort[df_cohort['COHORT'] == '1']['PATNO'])
merged_df = merged_df[merged_df['PATNO'].isin(pd_patnos)]
print(pd_patnos)

# Ensure PATNO and EVENT_ID are strings
merged_df['PATNO'] = merged_df['PATNO'].astype(str)
merged_df['EVENT_ID'] = merged_df['EVENT_ID'].astype(str)

# Get the visit sequences per patient in filterdata
visit_sequences = merged_df.groupby('PATNO')['EVENT_ID'].apply(list)

positions = {}
for visits in visit_sequences:
    for pos, eid in enumerate(visits, 1):
        if eid not in positions:
            positions[eid] = []
        positions[eid].append(pos)

# Average position per EVENT_ID
mean_positions = {eid: sum(pos_list) / len(pos_list) for eid, pos_list in positions.items()}

# Sort EVENT_IDs by mean position
sorted_eids = sorted(mean_positions, key=mean_positions.get)
n = len(sorted_eids)

# Assign early, mid, late categories
visit_categories = {}
for i, eid in enumerate(sorted_eids):
    if i < n // 3:
        visit_categories[eid] = 'early'
    elif i < 2 * n // 3:
        visit_categories[eid] = 'mid'
    else:
        visit_categories[eid] = 'late'

# Map these categories to a new column in filterdata
merged_df['visit_phase'] = merged_df['EVENT_ID'].map(visit_categories)

print(merged_df[['EVENT_ID', 'visit_phase']].drop_duplicates())

import matplotlib.pyplot as plt

# Select all symptom columns from your merged_df except ID columns
symptom_cols = ['CLCKPII','CLCK2HND','CLCKNMRK',
    'CLCKNUIN','CLCKALNU','CLCKNUSP','CLCKNUED','CLCKTOT','MCAALTTM','MCACUBE','MCACLCKC','MCACLCKN','MCACLCKH','MCALION','MCARHINO','MCACAMEL','MCAFDS','MCABDS','MCAVIGIL','MCASER7','MCASNTNC','MCAVFNUM','MCAVF','MCAABSTR','MCAREC1','MCAREC2','MCAREC3','MCAREC4','MCAREC5','MCADATE','MCAMONTH','MCAYR','MCADAY','MCAPLACE','MCACITY'
]
symptom_cols = [col for col in symptom_cols if col in merged_df.columns]

# Convert these columns to numeric
for col in symptom_cols:
    merged_df[col] = pd.to_numeric(merged_df[col], errors='coerce')

# Define visit_phase_mapping as before if you're grouping by visit code phases
visit_phase_mapping = {
    'BL': 'early', 'R17': 'early', 'R18': 'mid', 'SC': 'early', 'TRANS': 'mid',
    'V01': 'mid', 'V02': 'mid', 'V03': 'mid', 'V04': 'mid', 'V05': 'mid',
    'V06': 'mid', 'V07': 'late', 'V08': 'late', 'V09': 'late', 'V10': 'late',
    'V11': 'late', 'V12': 'late', 'V14': 'late', 'V15': 'late', 'V17': 'late',
    'V18': 'late', 'R19': 'mid', 'R20': 'mid', 'V19': 'late', 'V20': 'late',
    'ST': 'mid', 'V13': 'late', 'V21': 'late', 'R16': 'early', 'V16': 'late',
    'R15': 'early', 'PW': 'early', 'RS1': 'mid', 'R21': 'mid', 'U02': 'mid',
    'U01': 'mid', 'V22': 'late', 'R14': 'mid', 'R13': 'early', 'LOG': 'early',
    'R08': 'early', 'R10': 'early', 'R12': 'early', 'R06': 'early', 'R04': 'early',
    'R01': 'early'
}

# Calculate mean symptom scores per visit
mean_scores = merged_df.groupby('EVENT_ID')[symptom_cols].mean()
filtered_visit_order = [v for v in visit_phase_mapping.keys() if v in mean_scores.index]
mean_scores = mean_scores.loc[filtered_visit_order]

# Assign phase to each symptom based on peak visit
symptom_phase_map = {}
for col in symptom_cols:
    max_score = mean_scores[col].max()
    max_visits = mean_scores.index[mean_scores[col] == max_score]
    phases = {visit_phase_mapping.get(visit, 'unknown') for visit in max_visits}
    if 'early' in phases:
        phase = 'early'
    elif 'mid' in phases:
        phase = 'mid'
    elif 'late' in phases:
        phase = 'late'
    else:
        phase = 'unknown'
    symptom_phase_map[col] = phase

# Plot with improved legend labels
plt.figure(figsize=(13, 7))
for col in symptom_cols:
    label = f"{col}: {symptom_phase_map[col].capitalize()}"
    plt.plot(mean_scores.index, mean_scores[col], marker='o', linewidth=2, label=label)

plt.ylabel('Symptom Severity or Presence (mean)', fontsize=14)
plt.xlabel('Visit (EVENT_ID)', fontsize=14)
plt.title('Neuro Symptom Progression Over Visits', fontsize=16)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.legend(loc='upper left', bbox_to_anchor=(1.0, 1.0), fontsize=10, ncol=2)
plt.tight_layout()
plt.show()

import os
merged_df.to_parquet(os.path.join(os.getcwd(), 'Merged_Df.parquet'))

import pandas as pd

file_paths = [
    r'E:\pd-data\non motor\sleep\REM_Sleep_Behavior_Disorder_Questionnaire_11Sep2025.csv'
]

# Load the CSV file
sleep = pd.read_csv(file_paths[0])

# Ensure patient and event IDs are string type
sleep['PATNO'] = sleep['PATNO'].astype(str)
sleep['EVENT_ID'] = sleep['EVENT_ID'].astype(str)

# List of columns to keep
cols_to_keep = [
    "DRMVIVID", "DRMAGRAC", "DRMNOCTB", "SLPLMBMV", "SLPINJUR",
    "DRMVERBL", "DRMFIGHT", "DRMUMV", "DRMOBJFL", "MVAWAKEN",
    "DRMREMEM", "SLPDSTRB", "STROKE", "HETRA", "PARKISM", "RLS",
    "NARCLPSY", "DEPRS", "EPILEPSY", "BRNINFM", "CNSOTH"
]

# Identifier columns
id_cols = ['PATNO', 'EVENT_ID']

# Select columns safely
sleep = sleep[id_cols + [col for col in cols_to_keep if col in sleep.columns]]

# DRMVIVID: Vivid dreams (0=No, 1=Yes)
# DRMAGRAC: Aggressive dreams (0=No, 1=Yes)
# DRMNOCTB: Nocturnal dream behaviors (e.g., dream enactment; 0=No, 1=Yes)
# SLPLMBMV: Limb movements in sleep (0=No, 1=Yes)
# SLPINJUR: Injury to self/bed-partner during sleep (0=No, 1=Yes)
# DRMVERBL: Verbal behavior (talking/yelling) during sleep (0=No, 1=Yes)
# DRMFIGHT: Fighting during sleep/dreams (0=No, 1=Yes)
# DRMUMV: Unusual movements in dreams (0=No, 1=Yes)
# DRMOBJFL: Falling/kicking/hitting objects from bed (0=No, 1=Yes)
# MVAWAKEN: Movements that awaken the sleeper (0=No, 1=Yes)
# DRMREMEM: Remembers dreams (0=No, 1=Yes)
# SLPDSTRB: General sleep disturbances (0=No, 1=Yes)
# STROKE: History of stroke (0=No, 1=Yes)
# HETRA: Head trauma history (0=No, 1=Yes)
# PARKISM: Diagnosis of parkinsonism (0=No, 1=Yes)
# RLS: Restless Legs Syndrome (0=No, 1=Yes)
# NARCLPSY: Narcolepsy (0=No, 1=Yes)
# DEPRS: Depression (0=No, 1=Yes)
# EPILEPSY: Epilepsy (0=No, 1=Yes)
# BRNINFM: Brain inflammation (0=No, 1=Yes)
# CNSOTH: Other CNS (central nervous system) problems (0=No, 1=Yes)

# Ensure PATNO is string in both DataFrames
df_cohort['PATNO'] = df_cohort['PATNO'].astype(str)
df_cohort['COHORT'] = df_cohort['COHORT'].astype(str)
sleep['PATNO'] = sleep['PATNO'].astype(str)

df_cohort['COHORT'] = df_cohort['COHORT'].str.strip()
df_cohort['PATNO'] = df_cohort['PATNO'].str.strip()
pd_patnos = set(df_cohort[df_cohort['COHORT'] == '1']['PATNO'])
sleep = sleep[sleep['PATNO'].isin(pd_patnos)]
print(pd_patnos)

# Ensure PATNO and EVENT_ID are strings
sleep['PATNO'] = sleep['PATNO'].astype(str)
sleep['EVENT_ID'] = sleep['EVENT_ID'].astype(str)

# Get the visit sequences per patient in sleep
visit_sequences = sleep.groupby('PATNO')['EVENT_ID'].apply(list)

positions = {}
for visits in visit_sequences:
    for pos, eid in enumerate(visits, 1):
        if eid not in positions:
            positions[eid] = []
        positions[eid].append(pos)

# Average position per EVENT_ID
mean_positions = {eid: sum(pos_list) / len(pos_list) for eid, pos_list in positions.items()}

# Sort EVENT_IDs by mean position
sorted_eids = sorted(mean_positions, key=mean_positions.get)
n = len(sorted_eids)

# Assign early, mid, late categories
visit_categories = {}
for i, eid in enumerate(sorted_eids):
    if i < n // 3:
        visit_categories[eid] = 'early'
    elif i < 2 * n // 3:
        visit_categories[eid] = 'mid'
    else:
        visit_categories[eid] = 'late'

# Map these categories to a new column in sleep
sleep['visit_phase'] = sleep['EVENT_ID'].map(visit_categories)

print(sleep[['EVENT_ID', 'visit_phase']].drop_duplicates())

import matplotlib.pyplot as plt

sleep_symptom_cols = [
    "DRMVIVID", "DRMAGRAC", "DRMNOCTB", "SLPLMBMV", "SLPINJUR", "DRMVERBL", "DRMFIGHT", "DRMUMV",
    "DRMOBJFL", "MVAWAKEN", "DRMREMEM", "SLPDSTRB", "STROKE", "HETRA", "PARKISM", "RLS",
    "NARCLPSY", "DEPRS", "EPILEPSY", "BRNINFM", "CNSOTH"
]

visit_phase_mapping = {
    'BL': 'early', 'R17': 'early', 'R18': 'mid', 'SC': 'early', 'TRANS': 'mid',
    'V01': 'mid', 'V02': 'mid', 'V03': 'mid', 'V04': 'mid', 'V05': 'mid',
    'V06': 'mid', 'V07': 'late', 'V08': 'late', 'V09': 'late', 'V10': 'late',
    'V11': 'late', 'V12': 'late', 'V14': 'late', 'V15': 'late', 'V17': 'late',
    'V18': 'late', 'R19': 'mid', 'R20': 'mid', 'V19': 'late', 'V20': 'late',
    'ST': 'mid', 'V13': 'late', 'V21': 'late', 'R16': 'early', 'V16': 'late',
    'R15': 'early', 'PW': 'early', 'RS1': 'mid', 'R21': 'mid', 'U02': 'mid',
    'U01': 'mid', 'V22': 'late', 'R14': 'mid', 'R13': 'early', 'LOG': 'early',
    'R08': 'early', 'R10': 'early', 'R12': 'early', 'R06': 'early', 'R04': 'early',
    'R01': 'early'
}

# Convert symptom values to binary presence (1 if symptom value == 1, else 0)
mean_presence = sleep.groupby('EVENT_ID')[sleep_symptom_cols].apply(
    lambda df: df.applymap(lambda x: 1 if x == 1 else 0).mean()
)

# Filter visit order for plotting
filtered_visit_order = [v for v in visit_phase_mapping.keys() if v in mean_presence.index]
mean_presence = mean_presence.loc[filtered_visit_order]

# Map phase (early > mid > late) based on max mean presence
symptom_phase_map = {}
for col in sleep_symptom_cols:
    max_val = mean_presence[col].max()
    max_visits = mean_presence.index[mean_presence[col] == max_val]
    phases = {visit_phase_mapping.get(v, 'unknown') for v in max_visits}
    if 'early' in phases:
        phase = 'early'
    elif 'mid' in phases:
        phase = 'mid'
    elif 'late' in phases:
        phase = 'late'
    else:
        phase = 'unknown'
    symptom_phase_map[col] = phase

plt.figure(figsize=(13, 7))
for col in sleep_symptom_cols:
    label = f"{col}: {symptom_phase_map[col].capitalize()}"
    plt.plot(mean_presence.index, mean_presence[col], marker='o', linewidth=2, label=label)

plt.ylabel('Symptom Presence (mean proportion)', fontsize=14)
plt.xlabel('Visit (EVENT_ID)', fontsize=14)
plt.title('Sleep Symptom Onset Progression by Visit', fontsize=16)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.legend(loc='upper left', bbox_to_anchor=(1.0, 1.0), fontsize=10, ncol=2)
plt.tight_layout()
plt.show()

import os
sleep.to_parquet(os.path.join(os.getcwd(), 'sleep.parquet'))

